# 类
--- 
## 构造函数和析构函数
1. 构造函数 (Constructor) —— “对象诞生的保险”
目的：初始化成员，将内存里的随机垃圾值替换为有效数据。

触发：执行 new 或直接创建对象时，系统自动调用。

书写位置：类内部 public 区，函数名与类名完全一致。

类内初始化 (int x=0)：

如果不写构造函数，默认构造函数会采用此值。

如果有构造函数且未处理该变量，此值依然生效。

函数体 { }：用于写逻辑判断、打印日志、执行初始化函数。

2. 析构函数 (Destructor) —— “对象消亡的善后”
目的：清理资源。如果在构造函数里 new 了内存，必须在析构里 delete。

触发：执行 delete 或对象生命周期结束（遇到 }）时自动调用。

语法：~类名()，无参数，无返回值。

书写位置：通常紧跟在构造函数之后。

3. 核心解惑
不写会怎样？ 编译器会生成空的函数。但基本类型（如 int）不会被清零，仍是垃圾值。

delete 与 ~xxx：执行 delete 指针 的本质就是：先调用析构函数，再收回物理内存。

new 与 构造函数：执行 new 的本质就是：先申请物理内存，再调用构造函数。

类内函数：构造函数不会自动调用普通成员函数，除非你手动在 { } 里写下调用代码。

## 创建对象的方式
1. 栈空间创建（自动管理）
语法：类名 对象名(参数);

特点：

自动管理：执行到所在的大括号 } 结束时，系统自动调用析构函数。

访问方式：使用点号 . 访问成员（如 obj.show()）。

效率：速度极快，内存分配由编译器完成。

适用场景：绝大多数局部变量、生命周期短暂的对象。

2. 堆空间创建（手动管理）
语法：类名* 指针名 = new 类名(参数);

特点：

手动管理：必须显式执行 delete 指针; 才会调用析构函数并释放内存，否则会导致内存泄漏。

访问方式：使用箭头 -> 访问成员（如 ptr->show()）。

灵活性：对象可以跨函数存在，直到你手动删除它。

适用场景：需要在函数结束后继续存在的对象、大型对象、或需要实现多态（父类指针指向子类对象）时。

3. 核心解惑
什么时候调构造？ 无论是执行到声明语句还是执行 new，都会立即调用构造函数。

符号区别：

点 .：对象就在你手里，直接点。

箭头 ->：你手里只有个地址（指针），需要顺着箭头找到背后的对象。

忘了 delete 会怎样？ 对象永远不会被销毁，其析构函数永远不会执行，直到程序完全关闭。



## 运算符重载
### 1. 核心概念
原始运算符只能处理内置数据类型,重载使其可以处理自定义对象
只能重载已有的运算符，不能创造新的符号（如 `**`），且不能改变内置类型的运算符行为。

---

### 2. 语法结构

根据操作数的位置，主要分为两种实现方式：

A. 成员函数格式

适用于左侧操作数是本类对象的情况（如 `obj1 + obj2` 实际上是 `obj1.operator+(obj2)`）//即left.operator(right),left隐含为 this 指针,出现在参数列表中

返回值类型 operator 运算符 (参数列表) {
    // 逻辑实现
}

B. 非成员函数（友元）格式

适用于左侧操作数不是本类对象的情况（最典型的是 `cout << obj`）。

```cpp
friend 返回值类型 operator 运算符 (参数1, 参数2) {
    // 逻辑实现
}

//都多一friend关键字,即operator(left, right)出现在参数列表第 1 位出现在参数列表第 2 位

### 3. 常见运算符重载实现（以 `arr` 类为例）

 ① 下标运算符 `[]` (必须是成员函数)

让容器类可以像数组一样通过索引访问。

```cpp
// 返回指针，支持通过下标获取动物实例
animals* operator[](size_t index) {
    if (index >= count) return nullptr; // 越界保护
    return data[index];
}

```
 ② 赋值运算符 `=` (必须是成员函数)

**这是处理动态内存分配（new）的类最关键的重载**，用于实现“深拷贝”，防止多个对象指向同一块内存导致崩溃。

```cpp
arr& operator=(const arr& other) {
    if (this == &other) return *this; // 1. 自我赋值检查
    delete[] data;                   // 2. 释放原有内存
    this->cap = other.cap;
    this->count = other.count;
    this->data = new animals*[cap];  // 3. 分配新空间
    for (size_t i = 0; i < count; ++i) {
        this->data[i] = other.data[i]; // 4. 拷贝内容
    }
    return *this;                    // 5. 返回引用支持链式赋值
}

```

③ 输出流运算符 `<<` (必须是非成员函数)

通常为了访问私有成员，会在类内声明为 `friend`。

```cpp
friend std::ostream& operator<<(std::ostream& os, const arr& obj) {
    os << "Array(size: " << obj.count << "/" << obj.cap << ")";
    return os; 
}

```

---

### 4. 避坑指南与规则

| **不可重载** | `.` (成员访问), `::` (作用域), `?:` (条件), `sizeof` |
| **语义一致性** | 重载 `+` 应该做加法相关的事，不要重载 `+` 却执行删除操作 |
| **短路特性** | 不要重载 `&&` 和 ` |
| **返回值** | 赋值运算符 `=` 返回引用；比较运算符 `==` 返回 `bool` |

---

### 5. 总结：为什么要重载？

1. **直观性**：`a + b` 比 `a.add(b)` 更符合人类直觉。
2. **通用性**：支持标准库算法（如使用 `std::sort` 需要重载 `<`）。
3. **安全性**：通过重载 `=` 确保含有指针成员的对象能正确拷贝内存。

## this指针的用法
这是一份关于 **C++ `this` 指针** 的深度总结笔记，结合了我们之前讨论的对象模型与内存机制：

###  1. 定义与本质
 只存在非静态函数中,指向当前调用对象的函数,只读不可修改赋值

### 2. 核心工作原理

* **自动传递**：当你调用 `obj.func()` 时，编译器会自动将对象的地址 `&obj` 作为隐藏参数传递给函数。
* **代码共享**：虽然同一类的多个对象共享同一份成员函数代码，但通过 `this` 指针，函数能够准确区分并操作对应对象的数据成员。
* **转换模型**：
* **你的代码**：`obj.add(data);`
* **编译器理解**：`Class::add(&obj, data);` → 内部变为 `this->data = data;`

### 3. 三大核心用途

| **解决命名冲突** | `this->cap = cap;` | 当局部变量（参数）与成员变量同名时进行区分。 |
| **返回对象本身** | `return *this;` | 用于**赋值运算符重载**，实现链式操作（如 `a = b = c`）。 |
| **自我赋值检查** | `if (this == &other)` | 在重载 `=` 时，判断是否是不小心自己给自己赋值，防止误删内存。 |

### 4. `this` 与 静态成员函数 (Static)

* **非静态函数**：属于**对象**级别，拥有 `this` 指针，可以访问所有成员。
* **静态函数 (static)**：属于**类**级别，**没有 `this` 指针**。
* **结果**：静态函数无法直接访问非静态成员变量（因为不知道是哪个对象的），只能访问静态成员变量。
  
### 5. 常见误区澄清

* **误区 1**：`this` 存储在对象内部吗？
* **真相**：不。`this` 只是一个**形参**，在函数调用时压入栈中，函数结束即销毁。对象占用的内存只包含成员变量。

* **误区 2**：成员函数属于对象吗？
* **真相**：对象只包含数据。成员函数存放在代码区，由所有对象共享。`this` 是连接“通用代码”与“特定对象数据”的桥梁。

**💡 小结：**
在 C++ 中，`this` 就像是对象的“自我意识”。它让通用的函数逻辑能够知道：“我现在正在处理的是我自己的 `data`，而不是隔壁对象的 `data`。”

## 迭代器
### 1. 核心定义

* **本质**：迭代器是一个**特殊的类对象**。它通过封装指针，提供了一套统一的接口来访问容器中的元素，而无需暴露容器的内部结构。
* **设计模式**：属于“迭代器模式”，实现了**算法与容器的解耦**。即：算法（如排序、查找）不直接操作容器，而是通过迭代器操作数据。

---

### 2. 必备运算符重载

要让一个类成为合格的迭代器，它必须至少重载以下三个运算符：

| 运算符 | 作用 | 模拟的行为 |
| --- | --- | --- |
| **`operator*`** | **解引用**：获取当前迭代器指向的数据内容。 | 像指针一样 `*it` 取值。 |
| **`operator++`** | **自增**：定义如何移动到下一个位置（连续内存移动或链表跳转）。 | 像指针一样 `it++` 移动。 |
| **`operator!=`** | **比较**：判断两个迭代器是否指向不同的位置。 | 用于判断是否到达 `end()`。 |

---

### 3. 语法糖：基于范围的 for 循环 (Range-based for)

#### 3.1 语法形式

for (auto a : myZoo) { ... }


#### 3.2 运行机制（编译器展开）

当你写下上述代码时，编译器会自动将其转换为传统的迭代器循环：

1. 调用容器的 `myZoo.begin()` 获取起始迭代器。
2. 调用容器的 `myZoo.end()` 获取结束标记。
3. 循环判断 `it != end`，执行 `*it` 取值，并执行 `++it` 步进。

#### 3.3 容器适配协议

要让自定义类（如你的 `arr`）支持此语法糖，类中必须定义：

* **`begin()`**：返回指向首元素的迭代器。
* **`end()`**：返回指向末尾之后（越界位）的迭代器。

---

### 4. 迭代器的分类与效率

根据需求，我们可以通过 `auto` 的修饰符来控制遍历行为：

* **`for (auto a : container)`**：**值拷贝**。适用于元素本身很小（如指针、基本类型）的情况。
* **`for (auto& a : container)`**：**引用传递**。当你需要修改容器内元素的值时使用。
* **`for (const auto& a : container)`**：**只读引用**。效率最高，防止大型对象拷贝且保证安全。

---

### 5. 迭代器 vs 指针

| 特性 | 指针 (`T*`) | 迭代器类 (`Iterator`) |
| --- | --- | --- |
| **类型** | 内置基本类型 | 自定义类或结构体 |
| **灵活性** | 仅限连续内存（数组） | 适配所有数据结构（链表、树、哈希等） |
| **安全性** | 容易发生越界或野指针 | 封装了边界检查逻辑，相对安全 |

---

### 6. 总结：为什么要用迭代器？

1. **抹平差异**：无论容器底层是数组、链表还是二叉树，程序员都用同样的 `it++` 遍历。
2. **支持 STL**：让自定义容器能直接使用标准库提供的 100 多个算法（如 `std::sort`, `std::find`）。
3. **代码简洁**：配合语法糖，让 C++ 代码具备现代语言（如 Python/Java）的简洁感。

## 

