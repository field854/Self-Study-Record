# 类
--- 
## 构造函数和析构函数
1. 构造函数 (Constructor) —— “对象诞生的保险”
目的：初始化成员，将内存里的随机垃圾值替换为有效数据。

触发：执行 new 或直接创建对象时，系统自动调用。

书写位置：类内部 public 区，函数名与类名完全一致。

类内初始化 (int x=0)：

如果不写构造函数，默认构造函数会采用此值。

如果有构造函数且未处理该变量，此值依然生效。

函数体 { }：用于写逻辑判断、打印日志、执行初始化函数。

2. 析构函数 (Destructor) —— “对象消亡的善后”
目的：清理资源。如果在构造函数里 new 了内存，必须在析构里 delete。

触发：执行 delete 或对象生命周期结束（遇到 }）时自动调用。

语法：~类名()，无参数，无返回值。

书写位置：通常紧跟在构造函数之后。

3. 核心解惑
不写会怎样？ 编译器会生成空的函数。但基本类型（如 int）不会被清零，仍是垃圾值。

delete 与 ~xxx：执行 delete 指针 的本质就是：先调用析构函数，再收回物理内存。

new 与 构造函数：执行 new 的本质就是：先申请物理内存，再调用构造函数。

类内函数：构造函数不会自动调用普通成员函数，除非你手动在 { } 里写下调用代码。

## 创建对象的方式
1. 栈空间创建（自动管理）
语法：类名 对象名(参数);

特点：

自动管理：执行到所在的大括号 } 结束时，系统自动调用析构函数。

访问方式：使用点号 . 访问成员（如 obj.show()）。

效率：速度极快，内存分配由编译器完成。

适用场景：绝大多数局部变量、生命周期短暂的对象。

2. 堆空间创建（手动管理）
语法：类名* 指针名 = new 类名(参数);

特点：

手动管理：必须显式执行 delete 指针; 才会调用析构函数并释放内存，否则会导致内存泄漏。

访问方式：使用箭头 -> 访问成员（如 ptr->show()）。

灵活性：对象可以跨函数存在，直到你手动删除它。

适用场景：需要在函数结束后继续存在的对象、大型对象、或需要实现多态（父类指针指向子类对象）时。

3. 核心解惑
什么时候调构造？ 无论是执行到声明语句还是执行 new，都会立即调用构造函数。

符号区别：

点 .：对象就在你手里，直接点。

箭头 ->：你手里只有个地址（指针），需要顺着箭头找到背后的对象。

忘了 delete 会怎样？ 对象永远不会被销毁，其析构函数永远不会执行，直到程序完全关闭。
